#property copyright   "Generated by AI Assistant"
#property version     "1.00"
#property description "Advanced Multi-Indicator EA with dynamic risk & ATR-based SL/TP"
#property strict

#include <Trade/Trade.mqh>

//=============================
// Inputs
//=============================
input string   InpStrategySection            = "---------- Strategy ----------";
input ENUM_TIMEFRAMES InpTimeframe           = PERIOD_H1;               // Signal timeframe
input bool     InpOnlyNewBar                 = true;                    // Generate signals only on new bar
input int      InpConfluenceRequired         = 3;                       // Number of signals required to enter
input bool     InpUseTrendFilter             = true;                    // Use EMA trend filter
input int      InpFastEMA                    = 50;                      // Fast EMA period
input int      InpSlowEMA                    = 200;                     // Slow EMA period
input bool     InpUseRSI                     = true;                    // Use RSI filter
input int      InpRSIPeriod                  = 14;                      // RSI period
input int      InpRSIOverbought              = 70;                      // RSI overbought
input int      InpRSIOversold                = 30;                      // RSI oversold
input bool     InpUseMACD                    = true;                    // Use MACD filter
input int      InpMACDFastEMA                = 12;                      // MACD fast EMA
input int      InpMACDSlowEMA                = 26;                      // MACD slow EMA
input int      InpMACDSignal                 = 9;                       // MACD signal period
input bool     InpUseADX                     = true;                    // Use ADX filter
input int      InpADXPeriod                  = 14;                      // ADX period
input double   InpADXThreshold               = 18.0;                    // ADX minimum trend strength

input string   InpRiskSection                = "---------- Risk ----------";
input double   InpRiskPerTradePercent        = 1.0;                     // Risk per trade (% of balance)
input double   InpMaxSpreadPoints            = 250.0;                   // Max spread in points to allow trading
input double   InpATRPeriod                  = 14;                      // ATR period for SL/TP
input double   InpATRMulSL                   = 2.0;                     // ATR multiple for SL
input double   InpBaseRR                     = 1.20;                    // Base reward:risk for TP
input double   InpMinRR                      = 0.80;                    // Minimum RR when win rate is low
input double   InpMaxRR                      = 2.50;                    // Maximum RR when win rate is high
input int      InpRollingTrades              = 30;                      // Rolling window size for win-rate adaptation

input string   InpManagementSection          = "------- Management -------";
input bool     InpUseBreakeven               = true;                    // Move SL to BE at 1R
input double   InpBreakevenBufferPoints      = 10.0;                    // Extra points beyond BE
input bool     InpUseTrailingStop            = true;                    // ATR-based trailing stop
input double   InpTrailingATRMul             = 1.5;                     // ATR multiple for trailing stop
input int      InpMaxPositionsPerSymbol      = 1;                       // Max concurrent positions per symbol for this EA

input string   InpFilterSection              = "--------- Filters ---------";
input bool     InpRestrictToMajorsAndGold    = true;                    // Only trade XAUUSD and major FX pairs
input string   InpAllowedSymbolsCSV          = "XAUUSD,EURUSD,GBPUSD,USDJPY,USDCHF,USDCAD,AUDUSD,NZDUSD"; // Allowed list
input int      InpStartHourUTC               = 0;                       // Trading session start (UTC hour)
input int      InpEndHourUTC                 = 24;                      // Trading session end (UTC hour, 24 means disabled)

input string   InpExecSection                = "--------- Execution ---------";
input ulong    InpMagicNumber                = 905123;                  // Magic number
input int      InpSlippagePoints             = 50;                      // Max price deviation in points
input bool     InpAllowShort                 = true;                    // Allow short trades
input bool     InpAllowLong                  = true;                    // Allow long trades

//=============================
// Globals
//=============================
CTrade Trade;

int handleEMA_Fast = INVALID_HANDLE;
int handleEMA_Slow = INVALID_HANDLE;
int handleRSI      = INVALID_HANDLE;
int handleMACD     = INVALID_HANDLE; // buffer 0 main, 1 signal, 2 hist
int handleADX      = INVALID_HANDLE; // buffer 0 main +DI, 1 -DI, 2 ADX
int handleATR      = INVALID_HANDLE;

datetime lastBarTime = 0;
string   statsFileName;

//=============================
// Utility
//=============================
bool IsSymbolAllowed(const string sym)
{
	if(!InpRestrictToMajorsAndGold)
		return true;
	string csv = StringTrim(StringReplace(InpAllowedSymbolsCSV, " ", ""));
	int parts = StringSplit(csv, ',', NULL);
	string arr[];
	StringSplit(csv, ',', arr);
	for(int i=0;i<ArraySize(arr);++i)
	{
		if(StringLen(arr[i])==0) continue;
		if(StringFind(sym, arr[i])==0 || sym==arr[i]) // match prefix exact or full
			return true;
	}
	return false;
}

bool IsWithinTradingSession()
{
	if(InpEndHourUTC>=24 && InpStartHourUTC==0)
		return true;
	datetime now = TimeCurrent();
	MqlDateTime dt; TimeToStruct(now, dt);
	int hourUTC = dt.hour;
	if(InpStartHourUTC<=InpEndHourUTC)
		return (hourUTC>=InpStartHourUTC && hourUTC<InpEndHourUTC);
	// Overnight window (e.g., 22 -> 6)
	return (hourUTC>=InpStartHourUTC || hourUTC<InpEndHourUTC);
}

bool GetSeries(const int handle, const int bufferIndex, const int count, double &out[])
{
	ArraySetAsSeries(out, true);
	int copied = CopyBuffer(handle, bufferIndex, 0, count, out);
	return (copied==count);
}

bool EnsureSinglePositionPerSymbol()
{
	int total = PositionsTotal();
	int countForSymbol = 0;
	for(int i=0;i<total;++i)
	{
		ulong ticket = PositionGetTicket(i);
		if(!PositionSelectByTicket(ticket))
			continue;
		if(PositionGetInteger(POSITION_MAGIC)==(long)InpMagicNumber && PositionGetString(POSITION_SYMBOL)==_Symbol)
			countForSymbol++;
	}
	return (countForSymbol < InpMaxPositionsPerSymbol);
}

//=============================
// Indicators setup
//=============================
bool CreateIndicators()
{
	int tf = (int)InpTimeframe;
	if(InpUseTrendFilter)
	{
		handleEMA_Fast = iMA(_Symbol, tf, InpFastEMA, 0, MODE_EMA, PRICE_CLOSE);
		handleEMA_Slow = iMA(_Symbol, tf, InpSlowEMA, 0, MODE_EMA, PRICE_CLOSE);
		if(handleEMA_Fast==INVALID_HANDLE || handleEMA_Slow==INVALID_HANDLE) return false;
	}
	if(InpUseRSI)
	{
		handleRSI = iRSI(_Symbol, tf, InpRSIPeriod, PRICE_CLOSE);
		if(handleRSI==INVALID_HANDLE) return false;
	}
	if(InpUseMACD)
	{
		handleMACD = iMACD(_Symbol, tf, InpMACDFastEMA, InpMACDSlowEMA, InpMACDSignal, PRICE_CLOSE);
		if(handleMACD==INVALID_HANDLE) return false;
	}
	if(InpUseADX)
	{
		handleADX = iADX(_Symbol, tf, InpADXPeriod);
		if(handleADX==INVALID_HANDLE) return false;
	}
	handleATR = iATR(_Symbol, tf, (int)InpATRPeriod);
	if(handleATR==INVALID_HANDLE) return false;
	return true;
}

void ReleaseIndicators()
{
	if(handleEMA_Fast!=INVALID_HANDLE) IndicatorRelease(handleEMA_Fast);
	if(handleEMA_Slow!=INVALID_HANDLE) IndicatorRelease(handleEMA_Slow);
	if(handleRSI!=INVALID_HANDLE)      IndicatorRelease(handleRSI);
	if(handleMACD!=INVALID_HANDLE)     IndicatorRelease(handleMACD);
	if(handleADX!=INVALID_HANDLE)      IndicatorRelease(handleADX);
	if(handleATR!=INVALID_HANDLE)      IndicatorRelease(handleATR);

	handleEMA_Fast = handleEMA_Slow = handleRSI = handleMACD = handleADX = handleATR = INVALID_HANDLE;
}

//=============================
// Win-rate rolling stats (file based)
//=============================
int   resultsBuffer[]; // 1 for win, 0 for loss
int   resultsCount = 0;

string BuildStatsFileName()
{
	string fn;
	fn = StringFormat("AdvancedEA_%s_%I64u.csv", _Symbol, InpMagicNumber);
	return fn;
}

void LoadStats()
{
	ArrayResize(resultsBuffer, 0);
	resultsCount = 0;
	int handle = FileOpen(statsFileName, FILE_READ|FILE_COMMON|FILE_TXT);
	if(handle==INVALID_HANDLE)
		return;
	while(!FileIsEnding(handle))
	{
		string line = FileReadString(handle);
		if(StringLen(line)==0) { if(FileIsEnding(handle)) break; else continue; }
		int val = (int)StringToInteger(line);
		if(val==0 || val==1)
		{
			int newSize = resultsCount+1;
			ArrayResize(resultsBuffer, newSize);
			resultsBuffer[resultsCount] = val;
			resultsCount = newSize;
		}
	}
	FileClose(handle);
}

void AppendResult(const bool win)
{
	// Load existing tail if not loaded
	if(resultsCount==0 && FileIsExist(statsFileName, FILE_COMMON))
		LoadStats();
	int val = win ? 1 : 0;
	// Append and enforce rolling window size
	int newSize = resultsCount + 1;
	ArrayResize(resultsBuffer, newSize);
	resultsBuffer[resultsCount] = val;
	resultsCount = newSize;
	if(resultsCount > InpRollingTrades)
	{
		// shift left
		for(int i=1;i<resultsCount;i++)
			resultsBuffer[i-1] = resultsBuffer[i];
		resultsCount--;
		ArrayResize(resultsBuffer, resultsCount);
	}
	// Persist
	int handle = FileOpen(statsFileName, FILE_WRITE|FILE_COMMON|FILE_TXT);
	if(handle!=INVALID_HANDLE)
	{
		for(int i=0;i<resultsCount;i++)
			FileWrite(handle, IntegerToString(resultsBuffer[i]));
		FileClose(handle);
	}
}

double GetRollingWinRate()
{
	if(resultsCount==0)
	{
		LoadStats();
	}
	if(resultsCount==0) return 0.5; // neutral default
	int wins=0;
	for(int i=0;i<resultsCount;i++) if(resultsBuffer[i]==1) wins++;
	double wr = (double)wins / (double)resultsCount;
	if(wr<0.05) wr = 0.05;
	if(wr>0.95) wr = 0.95;
	return wr;
}

// Map win-rate to RR between min and max, centered around base
// Linear mapping: wr 0.35 -> MinRR, wr 0.70 -> MaxRR, else interpolate and clamp
// If baseRR provided, we can bias slightly towards it

double ComputeAdaptiveRR()
{
	double wr = GetRollingWinRate();
	double wrLow = 0.35;
	double wrHigh = 0.70;
	double rr;
	if(wr<=wrLow) rr = InpMinRR;
	else if(wr>=wrHigh) rr = InpMaxRR;
	else rr = InpMinRR + (InpMaxRR-InpMinRR) * (wr - wrLow) / (wrHigh - wrLow);
	// blend with base
	double blended = 0.5*rr + 0.5*InpBaseRR;
	if(blended<InpMinRR) blended = InpMinRR;
	if(blended>InpMaxRR) blended = InpMaxRR;
	return blended;
}

//=============================
// Signals
//=============================
struct SignalSnapshot
{
	bool trendUp;
	bool trendDown;
	bool rsiBullish;
	bool rsiBearish;
	bool macdBullish;
	bool macdBearish;
	bool adxStrong;
	double atrPoints;
};

bool ReadIndicators(SignalSnapshot &sig, const int shift)
{
	double arrFast[3], arrSlow[3];
	double arrRSI[3];
	double arrMACDMain[3], arrMACDSignal[3], arrMACDHist[3];
	double arrADX[3], arrPlusDI[3], arrMinusDI[3];
	double arrATR[3];

	if(InpUseTrendFilter)
	{
		if(CopyBuffer(handleEMA_Fast, 0, shift, 3, arrFast)!=3) return false;
		if(CopyBuffer(handleEMA_Slow, 0, shift, 3, arrSlow)!=3) return false;
	}
	if(InpUseRSI)
	{
		if(CopyBuffer(handleRSI, 0, shift, 3, arrRSI)!=3) return false;
	}
	if(InpUseMACD)
	{
		if(CopyBuffer(handleMACD, 0, shift, 3, arrMACDMain)!=3) return false;
		if(CopyBuffer(handleMACD, 1, shift, 3, arrMACDSignal)!=3) return false;
		if(CopyBuffer(handleMACD, 2, shift, 3, arrMACDHist)!=3) return false;
	}
	if(InpUseADX)
	{
		if(CopyBuffer(handleADX, 2, shift, 3, arrADX)!=3) return false; // ADX
		if(CopyBuffer(handleADX, 0, shift, 3, arrPlusDI)!=3) return false; // +DI
		if(CopyBuffer(handleADX, 1, shift, 3, arrMinusDI)!=3) return false; // -DI
	}
	if(CopyBuffer(handleATR, 0, shift, 3, arrATR)!=3) return false;

	sig.trendUp   = !InpUseTrendFilter || (arrFast[0] > arrSlow[0]);
	sig.trendDown = !InpUseTrendFilter || (arrFast[0] < arrSlow[0]);

	sig.rsiBullish = !InpUseRSI || (arrRSI[0] > 50.0 && arrRSI[1] <= 50.0) || (arrRSI[0] > InpRSIOversold && arrRSI[1] <= InpRSIOversold);
	sig.rsiBearish = !InpUseRSI || (arrRSI[0] < 50.0 && arrRSI[1] >= 50.0) || (arrRSI[0] < InpRSIOverbought && arrRSI[1] >= InpRSIOverbought);

	sig.macdBullish = !InpUseMACD || (arrMACDMain[0] > arrMACDSignal[0] && arrMACDHist[0] > 0.0);
	sig.macdBearish = !InpUseMACD || (arrMACDMain[0] < arrMACDSignal[0] && arrMACDHist[0] < 0.0);

	sig.adxStrong = !InpUseADX || (arrADX[0] >= InpADXThreshold && arrPlusDI[0] != EMPTY_VALUE && arrMinusDI[0] != EMPTY_VALUE);

	sig.atrPoints = arrATR[0] / _Point; // convert to points
	return true;
}

int ConfluenceForBuy(const SignalSnapshot &sig)
{
	int conf = 0;
	if(sig.trendUp) conf++;
	if(sig.rsiBullish) conf++;
	if(sig.macdBullish) conf++;
	if(sig.adxStrong) conf++;
	return conf;
}

int ConfluenceForSell(const SignalSnapshot &sig)
{
	int conf = 0;
	if(sig.trendDown) conf++;
	if(sig.rsiBearish) conf++;
	if(sig.macdBearish) conf++;
	if(sig.adxStrong) conf++;
	return conf;
}

//=============================
// Risk and sizing
//=============================

double NormalizeVolume(double volume)
{
	double minLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
	double maxLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
	double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
	if(volume < minLot) volume = minLot;
	if(volume > maxLot) volume = maxLot;
	int steps = (int)MathFloor((volume - minLot + 1e-12) / lotStep);
	double norm = minLot + steps * lotStep;
	return norm;
}

bool CalculatePositionSizeByRisk(const double stopPoints, double &outVolume)
{
	double riskMoney = AccountInfoDouble(ACCOUNT_BALANCE) * InpRiskPerTradePercent / 100.0;
	if(riskMoney <= 0.0) return false;

	double tickValue = 0.0; SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE, tickValue);
	double tickSize  = 0.0; SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE,  tickSize);
	if(tickValue<=0.0 || tickSize<=0.0) return false;

	double stopPriceDistance = stopPoints * _Point;
	double ticksAtStop = stopPriceDistance / tickSize;
	if(ticksAtStop <= 0.0) return false;

	double moneyPerLotAtStop = ticksAtStop * tickValue; // per 1.0 lot
	if(moneyPerLotAtStop <= 0.0) return false;

	double volume = riskMoney / moneyPerLotAtStop;
	outVolume = NormalizeVolume(volume);
	return (outVolume > 0.0);
}

bool SpreadIsAcceptable()
{
	double spreadPoints = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / _Point;
	return (spreadPoints <= InpMaxSpreadPoints);
}

//=============================
// Order placement
//=============================

bool OpenPosition(const bool isBuy, const double slPoints, const double tpPoints)
{
	MqlTick tick; if(!SymbolInfoTick(_Symbol, tick)) return false;
	double price = isBuy ? tick.ask : tick.bid;
	double sl    = isBuy ? price - slPoints*_Point : price + slPoints*_Point;
	double tp    = isBuy ? price + tpPoints*_Point : price - tpPoints*_Point;

	double volume;
	if(!CalculatePositionSizeByRisk(slPoints, volume)) return false;
	if(volume <= 0.0) return false;

	Trade.SetExpertMagicNumber(InpMagicNumber);
	Trade.SetDeviationInPoints(InpSlippagePoints);
	bool ok = isBuy ? Trade.Buy(volume, _Symbol, price, sl, tp, "AdvEA Buy")
			        : Trade.Sell(volume, _Symbol, price, sl, tp, "AdvEA Sell");
	return ok;
}

//=============================
// Position management
//=============================

void ManageOpenPositions()
{
	int total = PositionsTotal();
	if(total<=0) return;

	MqlTick tick; SymbolInfoTick(_Symbol, tick);

	for(int i=0;i<total;i++)
	{
		ulong ticket = PositionGetTicket(i);
		if(!PositionSelectByTicket(ticket)) continue;
		if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
		if(PositionGetInteger(POSITION_MAGIC) != (long)InpMagicNumber) continue;

		long type = PositionGetInteger(POSITION_TYPE);
		double priceOpen = PositionGetDouble(POSITION_PRICE_OPEN);
		double sl = PositionGetDouble(POSITION_SL);
		double tp = PositionGetDouble(POSITION_TP);
		double volume = PositionGetDouble(POSITION_VOLUME);

		// Compute 1R (open->SL distance)
		double oneRPoints = MathAbs((priceOpen - sl) / _Point);
		if(oneRPoints <= 0.0) continue;

		// Breakeven
		if(InpUseBreakeven)
		{
			if(type==POSITION_TYPE_BUY)
			{
				double distancePoints = (tick.bid - priceOpen) / _Point;
				if(distancePoints >= oneRPoints)
				{
					double newSL = priceOpen + InpBreakevenBufferPoints*_Point;
					if(newSL > sl)
					{
						Trade.PositionModify(ticket, newSL, tp);
					}
				}
			}
			else if(type==POSITION_TYPE_SELL)
			{
				double distancePoints = (priceOpen - tick.ask) / _Point;
				if(distancePoints >= oneRPoints)
				{
					double newSL = priceOpen - InpBreakevenBufferPoints*_Point;
					if(newSL < sl || sl==0.0)
					{
						Trade.PositionModify(ticket, newSL, tp);
					}
				}
			}
		}

		// Trailing stop based on ATR
		if(InpUseTrailingStop)
		{
			SignalSnapshot s; if(!ReadIndicators(s, 0)) continue; // use current ATR
			double trailPoints = s.atrPoints * InpTrailingATRMul;
			if(trailPoints <= 0.0) continue;

			if(type==POSITION_TYPE_BUY)
			{
				double newSL = tick.bid - trailPoints*_Point;
				if(newSL > sl && newSL < tick.bid)
					Trade.PositionModify(ticket, newSL, tp);
			}
			else if(type==POSITION_TYPE_SELL)
			{
				double newSL = tick.ask + trailPoints*_Point;
				if((sl==0.0 || newSL < sl) && newSL > tick.ask)
					Trade.PositionModify(ticket, newSL, tp);
			}
		}
	}
}

//=============================
// Trade transaction to update stats
//=============================

void OnTradeTransaction(const MqlTradeTransaction &trans,const MqlTradeRequest &request,const MqlTradeResult &result)
{
	if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
	{
		ulong dealTicket = trans.deal;
		if(HistorySelectByPosition(trans.position))
		{
			// We only react to closing deals
			long entry = (long)HistoryDealGetInteger(dealTicket, DEAL_ENTRY);
			if(entry == DEAL_ENTRY_OUT)
			{
				string sym = HistoryDealGetString(dealTicket, DEAL_SYMBOL);
				if(sym == _Symbol)
				{
					long magic = HistoryDealGetInteger(dealTicket, DEAL_MAGIC);
					if(magic == (long)InpMagicNumber)
					{
						double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
						AppendResult(profit > 0.0);
					}
				}
			}
		}
	}
}

//=============================
// OnInit/OnTick
//=============================

int OnInit()
{
	if(!IsSymbolAllowed(_Symbol))
	{
		Print("Symbol not allowed by filter: ", _Symbol);
		return INIT_PARAMETERS_INCORRECT;
	}
	if(!CreateIndicators())
	{
		Print("Failed to create indicators");
		return INIT_FAILED;
	}
	statsFileName = BuildStatsFileName();
	LoadStats();
	return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason)
{
	ReleaseIndicators();
}

void OnTick()
{
	if(!IsWithinTradingSession()) return;
	if(!SpreadIsAcceptable()) return;
	if(!EnsureSinglePositionPerSymbol()) return;

	ManageOpenPositions();

	// Signal only on new bar if requested
	if(InpOnlyNewBar)
	{
		MqlRates rates[]; int copied = CopyRates(_Symbol, (ENUM_TIMEFRAMES)InpTimeframe, 0, 2, rates);
		if(copied<2) return;
		ArraySetAsSeries(rates, true);
		if(lastBarTime == rates[0].time) return;
		lastBarTime = rates[0].time;
	}

	SignalSnapshot sig;
	if(!ReadIndicators(sig, 1)) return; // use closed bar data

	// Compute SL/TP points from ATR and adaptive RR
	double slPoints = MathMax(sig.atrPoints * InpATRMulSL, 1.0);
	double rr = ComputeAdaptiveRR();
	double tpPoints = slPoints * rr;

	int confBuy = ConfluenceForBuy(sig);
	int confSell = ConfluenceForSell(sig);

	if(InpAllowLong && confBuy >= InpConfluenceRequired)
	{
		OpenPosition(true, slPoints, tpPoints);
	}
	else if(InpAllowShort && confSell >= InpConfluenceRequired)
	{
		OpenPosition(false, slPoints, tpPoints);
	}
}