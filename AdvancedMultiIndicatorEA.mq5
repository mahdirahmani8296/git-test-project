//+------------------------------------------------------------------+
//|                                                    Advanced EA   |
//|                                    © 2024, AutoGenerated by AI  |
//|   Description: Multi-indicator Expert Advisor with advanced     |
//|                money management and risk control                |
//+------------------------------------------------------------------+
#property copyright "© 2024"
#property version   "1.00"
#property description "Advanced Multi-Indicator EA generated by AI"
#property strict

//--- input parameters
input double   InpRiskPerTrade      = 1.0;   // Risk per trade (% of balance)
input int      InpMagicNumber       = 55555; // Magic number
input double   InpLotsMin           = 0.01;  // Minimum lot size
input double   InpLotsMax           = 10.0;  // Maximum lot size
input int      InpSlippage          = 5;     // Slippage (points)
input int      InpStopMultiplier    = 2;     // ATR multiplier for Stop Loss
input int      InpTakeMultiplier    = 4;     // ATR multiplier for Take Profit
input bool     InpUseTrailingStop   = true;  // Enable trailing stop
input int      InpTrailingATRMult   = 1;     // ATR multiplier for trailing stop

//--- indicator periods
input int      InpFastEMAPeriod     = 12;    // Fast EMA
input int      InpSlowEMAPeriod     = 26;    // Slow EMA
input int      InpRSIPeriod         = 14;    // RSI Period
input int      InpRSIBuyLevel       = 30;    // RSI Oversold threshold
input int      InpRSISellLevel      = 70;    // RSI Overbought threshold
input int      InpATRPeriod         = 14;    // ATR Period

//--- global variables
int      handleFastEMA;
int      handleSlowEMA;
int      handleRSI;
int      handleATR;

//--- buffers to store latest indicator values
double   fastEMA[], slowEMA[], rsi[], atr[];

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   //--- create indicator handles
   handleFastEMA = iMA(_Symbol,_Period,InpFastEMAPeriod,0,MODE_EMA,PRICE_CLOSE);
   handleSlowEMA = iMA(_Symbol,_Period,InpSlowEMAPeriod,0,MODE_EMA,PRICE_CLOSE);
   handleRSI     = iRSI(_Symbol,_Period,InpRSIPeriod,PRICE_CLOSE);
   handleATR     = iATR(_Symbol,_Period,InpATRPeriod);

   if(handleFastEMA==INVALID_HANDLE || handleSlowEMA==INVALID_HANDLE || handleRSI==INVALID_HANDLE || handleATR==INVALID_HANDLE)
     {
      Print("Error creating indicator handles");
      return(INIT_FAILED);
     }

   //--- resize buffers
   ArraySetAsSeries(fastEMA,true);
   ArraySetAsSeries(slowEMA,true);
   ArraySetAsSeries(rsi,true);
   ArraySetAsSeries(atr,true);

   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   //--- release indicator handles
   if(handleFastEMA!=INVALID_HANDLE) IndicatorRelease(handleFastEMA);
   if(handleSlowEMA!=INVALID_HANDLE) IndicatorRelease(handleSlowEMA);
   if(handleRSI!=INVALID_HANDLE)     IndicatorRelease(handleRSI);
   if(handleATR!=INVALID_HANDLE)     IndicatorRelease(handleATR);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   //--- copy latest indicator data
   if(!CopyBuffer(handleFastEMA,0,0,3,fastEMA) ||
      !CopyBuffer(handleSlowEMA,0,0,3,slowEMA) ||
      !CopyBuffer(handleRSI,0,0,3,rsi) ||
      !CopyBuffer(handleATR,0,0,3,atr))
     {
      Print("Failed to copy indicator buffers");
      return;
     }

   double fast_prev = fastEMA[1];
   double slow_prev = slowEMA[1];
   double fast_curr = fastEMA[0];
   double slow_curr = slowEMA[0];

   //--- trading signals
   bool buySignal  = (fast_prev < slow_prev) && (fast_curr > slow_curr) && (rsi[0] < InpRSIBuyLevel);
   bool sellSignal = (fast_prev > slow_prev) && (fast_curr < slow_curr) && (rsi[0] > InpRSISellLevel);

   //--- manage positions
   ManageOpenOrders(buySignal,sellSignal);
   if(InpUseTrailingStop) ManageTrailingStop();
  }

//+------------------------------------------------------------------+
//| Calculate dynamic lot size                                       |
//+------------------------------------------------------------------+
 double CalculateLotSize(double stop_points)
  {
   double risk = AccountBalance() * (InpRiskPerTrade/100.0);
   double lot  = NormalizeDouble(risk / (stop_points * _Point * MarketInfo(_Symbol,MODE_TICKVALUE)),2);
   if(lot < InpLotsMin) lot = InpLotsMin;
   if(lot > InpLotsMax) lot = InpLotsMax;
   return(lot);
  }

//+------------------------------------------------------------------+
//| Manage order opening                                             |
//+------------------------------------------------------------------+
void ManageOpenOrders(bool buySignal,bool sellSignal)
  {
   int total = PositionsTotal();

   //--- if position exists, do nothing new
   if(total>0) return;

   double stop = atr[0]*InpStopMultiplier;
   double take = atr[0]*InpTakeMultiplier;

   if(buySignal)
     {
      double lot = CalculateLotSize(stop);
      double sl = NormalizeDouble(Bid - stop*_Point, _Digits);
      double tp = NormalizeDouble(Bid + take*_Point, _Digits);
      trade.Buy(lot,NULL,Ask,sl,tp,"AI Buy",InpMagicNumber);
     }
   else if(sellSignal)
     {
      double lot = CalculateLotSize(stop);
      double sl = NormalizeDouble(Ask + stop*_Point, _Digits);
      double tp = NormalizeDouble(Ask - take*_Point, _Digits);
      trade.Sell(lot,NULL,Bid,sl,tp,"AI Sell",InpMagicNumber);
     }
  }

//+------------------------------------------------------------------+
//| Trailing stop management                                         |
//+------------------------------------------------------------------+
void ManageTrailingStop()
  {
   int total = PositionsTotal();
   if(total==0) return;

   double trail_stop = atr[0]*InpTrailingATRMult;

   for(int i=0;i<total;i++)
     {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
        {
         double pos_price = PositionGetDouble(POSITION_PRICE_OPEN);
         double sl        = PositionGetDouble(POSITION_SL);
         double current   = (PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)?Bid:Ask;

         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)
           {
            double new_sl = NormalizeDouble(current - trail_stop*_Point,_Digits);
            if(new_sl > sl)
               trade.PositionModify(ticket,new_sl,PositionGetDouble(POSITION_TP));
           }
         else
           {
            double new_sl = NormalizeDouble(current + trail_stop*_Point,_Digits);
            if(new_sl < sl || sl==0)
               trade.PositionModify(ticket,new_sl,PositionGetDouble(POSITION_TP));
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| Include standard trade class                                     |
//+------------------------------------------------------------------+
#include <Trade\Trade.mqh>
CTrade trade;
//+------------------------------------------------------------------+