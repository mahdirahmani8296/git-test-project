//+------------------------------------------------------------------+
//|                                                   AdvancedEA.mq5 |
//|                        Generated by OpenAI Assistant             |
//|   An advanced multi-indicator Expert Advisor for MetaTrader 5    |
//|   Trades gold (XAUUSD) and major Forex pairs with dynamic        |
//|   position sizing, ATR-based stop loss, and adjustable TP ratio. |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "OpenAI"
#property version   "1.00"
#property description "EMA trend filter, MACD & RSI entry, ATR SL, RR TP, trailing stop"
#property strict

#include <Trade/Trade.mqh>
CTrade trade;

//---- input parameters
input double   RiskPercent        = 1.0;     // % equity risk per trade
input int      EMAPeriod          = 200;     // Trend filter EMA period
input int      RSIPeriod          = 14;      // RSI period
input double   RSI_Buy_Threshold  = 35.0;    // RSI oversold threshold
input double   RSI_Sell_Threshold = 65.0;    // RSI overbought threshold
input int      MACDFast           = 12;      // MACD fast EMA
input int      MACDSlow           = 26;      // MACD slow EMA
input int      MACDSignal         = 9;       // MACD signal SMA
input int      ATRPeriod          = 14;      // ATR period
input double   ATRMultiplierSL    = 2.0;     // SL = ATR * Multiplier
input double   RiskRewardRatio    = 2.0;     // TP = SL * Ratio
input bool     UseTrailingStop    = true;    // Enable trailing stop
input double   TrailingATRMult    = 1.0;     // Trailing stop = ATR * Mult at breakeven

//---- global variables
int emaHandle, rsiHandle, macdHandle, atrHandle;
double emaBuffer[], rsiBuffer[], macdMain[], macdSignal[], macdHist[], atrBuffer[];

//+------------------------------------------------------------------+
//| Expert initialization                                            |
//+------------------------------------------------------------------+
int OnInit()
  {
   //--- Create indicator handles
   emaHandle   = iMA(_Symbol, _Period, EMAPeriod, 0, MODE_EMA, PRICE_CLOSE);
   rsiHandle   = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   macdHandle  = iMACD(_Symbol, _Period, MACDFast, MACDSlow, MACDSignal, PRICE_CLOSE);
   atrHandle   = iATR(_Symbol, _Period, ATRPeriod);

   if(emaHandle==INVALID_HANDLE || rsiHandle==INVALID_HANDLE || macdHandle==INVALID_HANDLE || atrHandle==INVALID_HANDLE)
     {
      Print("Failed to create indicator handles");
      return(INIT_FAILED);
     }

   ArraySetAsSeries(emaBuffer,true);
   ArraySetAsSeries(rsiBuffer,true);
   ArraySetAsSeries(macdMain,true);
   ArraySetAsSeries(macdSignal,true);
   ArraySetAsSeries(macdHist,true);
   ArraySetAsSeries(atrBuffer,true);

   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   IndicatorRelease(emaHandle);
   IndicatorRelease(rsiHandle);
   IndicatorRelease(macdHandle);
   IndicatorRelease(atrHandle);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   if(!CopyBuffers())
      return;

   //--- trend determination
   double emaCurrent = emaBuffer[0];
   bool uptrend   = (Close[0] > emaCurrent);
   bool downtrend = (Close[0] < emaCurrent);

   //--- indicator conditions
   double rsiCurrent  = rsiBuffer[0];
   double macdHistCurr= macdHist[0];
   double macdHistPrev= macdHist[1];

   //--- ATR for SL/TP
   double atrCurr = atrBuffer[0];

   //--- Check positions
   if(PositionSelect(_Symbol))
     {
      // manage trailing stop
      if(UseTrailingStop)
         ManageTrailingStop(atrCurr);
      return; // only manage existing position; no new trades
     }

   //--- Entry signals
   if(uptrend && rsiCurrent < RSI_Buy_Threshold && macdHistPrev<0 && macdHistCurr>0)
      EnterTrade(ORDER_TYPE_BUY, atrCurr);
   else if(downtrend && rsiCurrent > RSI_Sell_Threshold && macdHistPrev>0 && macdHistCurr<0)
      EnterTrade(ORDER_TYPE_SELL, atrCurr);
  }

//+------------------------------------------------------------------+
//| Copy indicator buffers                                           |
//+------------------------------------------------------------------+
bool CopyBuffers()
  {
   if(CopyBuffer(emaHandle, 0, 0, 2, emaBuffer)<=0) return(false);
   if(CopyBuffer(rsiHandle, 0, 0, 1, rsiBuffer)<=0) return(false);
   if(CopyBuffer(macdHandle, 0, 0, 2, macdMain)<=0) return(false);
   if(CopyBuffer(macdHandle, 1, 0, 2, macdSignal)<=0) return(false);
   if(CopyBuffer(macdHandle, 2, 0, 2, macdHist)<=0) return(false);
   if(CopyBuffer(atrHandle, 0, 0, 1, atrBuffer)<=0) return(false);
   return(true);
  }

//+------------------------------------------------------------------+
//| Calculate lot size based on risk percent and SL pips             |
//+------------------------------------------------------------------+
double CalculateLot(double sl_points)
  {
   double risk_money = AccountInfoDouble(ACCOUNT_EQUITY) * RiskPercent / 100.0;
   double lot = risk_money / (sl_points * _Point * SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE));

   //--- adjust to minimal lot and steps
   double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double min_lot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double max_lot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   lot = MathMax(min_lot, MathFloor(lot/lot_step)*lot_step);
   lot = MathMin(lot, max_lot);
   return(lot);
  }

//+------------------------------------------------------------------+
//| Enter trade                                                      |
//+------------------------------------------------------------------+
void EnterTrade(ENUM_ORDER_TYPE order_type, double atr)
  {
   double sl_points = atr * ATRMultiplierSL / _Point;
   double lot = CalculateLot(sl_points);

   if(lot < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN))
     {
      Print("Lot size too small for risk parameters");
      return;
     }

   double price, sl, tp;
   if(order_type == ORDER_TYPE_BUY)
     {
      price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      sl    = price - atr * ATRMultiplierSL;
      tp    = price + atr * ATRMultiplierSL * RiskRewardRatio;
     }
   else // sell
     {
      price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      sl    = price + atr * ATRMultiplierSL;
      tp    = price - atr * ATRMultiplierSL * RiskRewardRatio;
     }

   trade.SetStopLoss(sl);
   trade.SetTakeProfit(tp);
   bool result;
   if(order_type == ORDER_TYPE_BUY)
      result = trade.Buy(lot, NULL, price, sl, tp, "AdvEA Buy");
   else
      result = trade.Sell(lot, NULL, price, sl, tp, "AdvEA Sell");

   if(!result)
      Print("OrderSend failed: ",GetLastError());
  }

//+------------------------------------------------------------------+
//| Manage trailing stop                                             |
//+------------------------------------------------------------------+
void ManageTrailingStop(double atr)
  {
   ulong ticket = PositionGetInteger(POSITION_TICKET);
   double price_open = PositionGetDouble(POSITION_PRICE_OPEN);
   double sl        = PositionGetDouble(POSITION_SL);
   double current_price = (PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);

   double new_sl;
   if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)
     {
      new_sl = current_price - atr * TrailingATRMult;
      if(new_sl > sl && new_sl > price_open)
         trade.PositionModify(ticket, new_sl, PositionGetDouble(POSITION_TP));
     }
   else // sell
     {
      new_sl = current_price + atr * TrailingATRMult;
      if((sl == 0 || new_sl < sl) && new_sl < price_open)
         trade.PositionModify(ticket, new_sl, PositionGetDouble(POSITION_TP));
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+