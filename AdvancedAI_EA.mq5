/*
   AdvancedAI_EA.mq5
   Expert Advisor combining indicators and basic ML-style scoring for autonomous trading on XAUUSD and major pairs.
   Author: Generated by AI
   NOTE: This is an initial skeleton. Fine-tune parameters and add training data for ML component before live trading.
*/
#property copyright   "AI"
#property link        "https://example.com"
#property version     "1.00"
#property strict

// Input parameters
input string InpSymbol              = "XAUUSD";     // Trading symbol
input ENUM_TIMEFRAMES InpTimeframe  = PERIOD_H1;     // Working timeframe
input double InpRiskPercent         = 1.0;           // Risk % per trade
input int    InpFastEMAPeriod       = 21;            // Fast EMA period
input int    InpSlowEMAPeriod       = 55;            // Slow EMA period
input int    InpRSIPeriod           = 14;            // RSI period
input int    InpATRPeriod           = 14;            // ATR period
input double InpATRMultiplierSL     = 1.5;           // ATR SL multiplier
input double InpATRMultiplierTP     = 3.0;           // ATR TP multiplier
input bool   InpUseTrailingStop     = true;          // Enable trailing stop
input double InpTrailingStartATR    = 1.0;           // Start trailing when price moves this ATR
input double InpTrailingStepATR     = 0.5;           // Trail step in ATR

// Global variables
int fastEmaHandle;
int slowEmaHandle;
int rsiHandle;
int atrHandle;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   fastEmaHandle = iMA(InpSymbol, InpTimeframe, InpFastEMAPeriod, 0, MODE_EMA, PRICE_CLOSE);
   slowEmaHandle = iMA(InpSymbol, InpTimeframe, InpSlowEMAPeriod, 0, MODE_EMA, PRICE_CLOSE);
   rsiHandle     = iRSI(InpSymbol, InpTimeframe, InpRSIPeriod, PRICE_CLOSE);
   atrHandle     = iATR(InpSymbol, InpTimeframe, InpATRPeriod);

   if(fastEmaHandle==INVALID_HANDLE || slowEmaHandle==INVALID_HANDLE ||
      rsiHandle==INVALID_HANDLE || atrHandle==INVALID_HANDLE)
     {
      Print("Failed to create indicator handles");
      return(INIT_FAILED);
     }
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   IndicatorRelease(fastEmaHandle);
   IndicatorRelease(slowEmaHandle);
   IndicatorRelease(rsiHandle);
   IndicatorRelease(atrHandle);
  }

//+------------------------------------------------------------------+
//| Trade decision helper                                            |
//+------------------------------------------------------------------+
double ComputeTradeScore()
  {
   // Placeholder ML-style scoring using simple weighted sum
   double emaFast, emaSlow, rsi, atr;
   if(CopyBuffer(fastEmaHandle, 0, 0, 1, emaFast)<0) return 0;
   if(CopyBuffer(slowEmaHandle, 0, 0, 1, emaSlow)<0) return 0;
   if(CopyBuffer(rsiHandle,     0, 0, 1, rsi)<0)     return 0;
   if(CopyBuffer(atrHandle,     0, 0, 1, atr)<0)     return 0;

   double trend  = (emaFast>emaSlow) ? 1 : -1; // simplistic trend
   double overbought = (rsi>70) ? -1 : (rsi<30) ? 1 : 0;

   double score = 0.6*trend + 0.4*overbought; // weights adjustable
   return score;
  }

//+------------------------------------------------------------------+
//| Calculate lot size based on risk                                 |
//+------------------------------------------------------------------+
double CalcLotSize(double stopLossPoints)
  {
   double riskMoney = AccountInfoDouble(ACCOUNT_BALANCE)*InpRiskPercent/100.0;
   double tickValue = SymbolInfoDouble(InpSymbol,SYMBOL_TRADE_TICK_VALUE);
   double lotStep   = SymbolInfoDouble(InpSymbol,SYMBOL_VOLUME_STEP);
   if(tickValue==0) return 0;
   double lot = riskMoney/(stopLossPoints*SymbolInfoDouble(InpSymbol,SYMBOL_TRADE_TICK_SIZE)/tickValue);
   lot = MathMax(lot, SymbolInfoDouble(InpSymbol,SYMBOL_VOLUME_MIN));
   lot = MathMin(lot, SymbolInfoDouble(InpSymbol,SYMBOL_VOLUME_MAX));
   lot = NormalizeDouble(MathFloor(lot/lotStep)*lotStep,2);
   return lot;
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   static datetime lastTradeTime=0;
   if(TimeCurrent()==lastTradeTime) return; // One trade decision per tick time

   double score = ComputeTradeScore();
   if(score==0) return;

   // Fetch ATR for SL/TP sizing
   double atr;
   if(CopyBuffer(atrHandle,0,0,1,atr)<0) return;
   double slPoints = atr*InpATRMultiplierSL/Point();
   double tpPoints = atr*InpATRMultiplierTP/Point();

   // Check existing positions
   if(PositionSelect(InpSymbol))
     {
      // manage trailing
      if(InpUseTrailingStop)
         ManageTrailingStop(atr);
      return;
     }

   // Entry conditions
   if(score>0.8) // bullish
     OpenPosition(ORDER_TYPE_BUY,slPoints,tpPoints);
   else if(score<-0.8) // bearish
     OpenPosition(ORDER_TYPE_SELL,slPoints,tpPoints);

   lastTradeTime=TimeCurrent();
  }

//+------------------------------------------------------------------+
//| Open position function                                           |
//+------------------------------------------------------------------+
void OpenPosition(ENUM_ORDER_TYPE type,double slPts,double tpPts)
  {
   double price = (type==ORDER_TYPE_BUY) ? SymbolInfoDouble(InpSymbol,SYMBOL_ASK)
                                         : SymbolInfoDouble(InpSymbol,SYMBOL_BID);
   double stopLoss = (type==ORDER_TYPE_BUY) ? price - slPts*Point() : price + slPts*Point();
   double takeProfit = (type==ORDER_TYPE_BUY) ? price + tpPts*Point() : price - tpPts*Point();

   double lot = CalcLotSize(slPts);
   if(lot<=0) { Print("Lot size calc error"); return; }

   MqlTradeRequest req;
   MqlTradeResult  res;
   ZeroMemory(req);
   ZeroMemory(res);

   req.action   = TRADE_ACTION_DEAL;
   req.symbol   = InpSymbol;
   req.volume   = lot;
   req.type     = type;
   req.price    = price;
   req.sl       = stopLoss;
   req.tp       = takeProfit;
   req.deviation= 20;
   req.magic    = 987654;
   req.comment  = "AdvancedAI_EA";

   if(!OrderSend(req,res))
      Print("OrderSend failed: ",GetLastError());
  }

//+------------------------------------------------------------------+
//| Manage trailing stop                                             |
//+------------------------------------------------------------------+
void ManageTrailingStop(double atr)
  {
   ENUM_POSITION_TYPE posType=(ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
   double priceCurrent = (posType==POSITION_TYPE_BUY) ? SymbolInfoDouble(InpSymbol,SYMBOL_BID)
                                                     : SymbolInfoDouble(InpSymbol,SYMBOL_ASK);
   double sl      = PositionGetDouble(POSITION_SL);
   double entry   = PositionGetDouble(POSITION_PRICE_OPEN);

   double trailStart = InpTrailingStartATR*atr;
   double trailStep  = InpTrailingStepATR*atr;

   if(posType==POSITION_TYPE_BUY)
     {
      if(priceCurrent - entry >= trailStart)
        {
         double newSL = priceCurrent - trailStep;
         if(newSL>sl)
            ModifySL(newSL);
        }
     }
   else if(posType==POSITION_TYPE_SELL)
     {
      if(entry - priceCurrent >= trailStart)
        {
         double newSL = priceCurrent + trailStep;
         if(newSL<sl || sl==0)
            ModifySL(newSL);
        }
     }
  }

//+------------------------------------------------------------------+
//| Modify SL helper                                                 |
//+------------------------------------------------------------------+
void ModifySL(double newSL)
  {
   MqlTradeRequest req;
   MqlTradeResult  res;
   ZeroMemory(req);
   ZeroMemory(res);

   req.action   = TRADE_ACTION_SLTP;
   req.symbol   = InpSymbol;
   req.sl       = newSL;
   req.magic    = 987654;

   if(!OrderSend(req,res))
      Print("Modify SL failed: ",GetLastError());
  }

//+------------------------------------------------------------------+
//| END                                                              |
//+------------------------------------------------------------------+