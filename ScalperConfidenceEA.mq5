#property copyright "Generated by AI"
#property version   "1.0"
#property strict
#property description "Scalper EA with confidence-based TP/SL and multi-indicator signals"
#property description "For MetaTrader 5 (MQL5)"

#include <Trade/Trade.mqh>

//=========================
// Inputs
//=========================
input ENUM_TIMEFRAMES InpTimeframe = PERIOD_M1;         // Signal timeframe
input double          InpRiskPerTradePercent = 0.5;     // Risk per trade (% of balance)
input int             InpMaxSpreadPoints = 30;          // Max spread (points)
input int             InpMaxPositionsPerSymbol = 1;     // Max concurrent positions per symbol
input int             InpDeviationPoints = 10;          // Max price deviation (points)
input ulong           InpMagic = 20250823;              // Magic number

// Indicator settings
input int   InpEMAFast = 12;
input int   InpEMASlow = 26;
input int   InpRSIPeriod = 14;
input int   InpStochK = 5;
input int   InpStochD = 3;
input int   InpStochSlow = 3;
input int   InpATRPeriod = 14;
input int   InpMACDFast = 12;
input int   InpMACDSlow = 26;
input int   InpMACDSignal = 9;

// Confidence and SL/TP dynamic mapping
input int    InpMinConfidenceToTrade = 60;              // 0..100
input double InpSL_ATR_Mult_Low  = 0.6;                 // SL ATR multiplier at high confidence
input double InpSL_ATR_Mult_High = 1.2;                 // SL ATR multiplier at low confidence
input double InpTP_ATR_Mult_Low  = 0.8;                 // TP ATR multiplier at low confidence
input double InpTP_ATR_Mult_High = 2.0;                 // TP ATR multiplier at high confidence

// Trade management
input bool   InpUseBreakEven = true;
input double InpBreakEvenTriggerPoints = 100;           // Move SL to BE after this profit (points)
input double InpBreakEvenOffsetPoints  = 10;            // Offset from entry (points)
input bool   InpUseTrailing = true;
input double InpTrailingStartPoints = 150;              // Start trailing after this profit (points)
input double InpTrailingStepPoints  = 20;               // Trail step (points)
input bool   InpUseTimeExit = true;
input int    InpMaxBarsInTrade = 200;                   // Close after N bars since open

// Session filters
input bool InpUseHourFilter = true;
input int  InpSessionStartHour = 7;                     // 24h clock (terminal time)
input int  InpSessionEndHour   = 22;
input bool InpTradeMonday    = true;
input bool InpTradeTuesday   = true;
input bool InpTradeWednesday = true;
input bool InpTradeThursday  = true;
input bool InpTradeFriday    = true;

// Direction control
input bool InpAllowLongs  = true;
input bool InpAllowShorts = true;

//=========================
// Globals
//=========================
CTrade g_trade;
int    g_handleEmaFast = INVALID_HANDLE;
int    g_handleEmaSlow = INVALID_HANDLE;
int    g_handleRSI     = INVALID_HANDLE;
int    g_handleStoch   = INVALID_HANDLE;
int    g_handleATR     = INVALID_HANDLE;
int    g_handleMACD    = INVALID_HANDLE;

MqlTick g_lastTick;
datetime g_lastSignalBarTime = 0; // to avoid multiple entries per bar

//=========================
// Utilities
//=========================
double PointValue() { return _Point; }
int    DigitsCount() { return (int)_Digits; }

bool CopyLatest(const int handle, const int buffer, double &val0, double &val1)
{
	if(handle == INVALID_HANDLE) return false;
	double data[3];
	int copied = CopyBuffer(handle, buffer, 0, 3, data);
	if(copied < 2) return false;
	val0 = data[0]; // current
	val1 = data[1]; // previous
	return true;
}

bool CheckSpreadOK()
{
	if(!SymbolInfoTick(_Symbol, g_lastTick)) return false;
	double spreadPoints = (g_lastTick.ask - g_lastTick.bid) / PointValue();
	return (spreadPoints <= InpMaxSpreadPoints);
}

bool CheckSessionOK()
{
	if(!InpUseHourFilter) return true;
	datetime now = TimeCurrent();
	MqlDateTime td; TimeToStruct(now, td);
	int wday = td.day_of_week; // 0=Sun ... 6=Sat
	bool dayOK = ((wday==1 && InpTradeMonday) || (wday==2 && InpTradeTuesday) || (wday==3 && InpTradeWednesday) || (wday==4 && InpTradeThursday) || (wday==5 && InpTradeFriday));
	if(!dayOK) return false;
	if(InpSessionStartHour <= InpSessionEndHour)
		return (td.hour >= InpSessionStartHour && td.hour < InpSessionEndHour);
	// overnight session window
	return (td.hour >= InpSessionStartHour || td.hour < InpSessionEndHour);
}

int CountOpenPositions()
{
	int total = PositionsTotal();
	int count = 0;
	for(int i=0; i<total; ++i)
	{
		ulong ticket = PositionGetTicket(i);
		if(ticket == 0) continue;
		if(!PositionSelectByTicket(ticket)) continue;
		if(PositionGetInteger(POSITION_MAGIC) == (long)InpMagic && PositionGetString(POSITION_SYMBOL) == _Symbol)
			count++;
	}
	return count;
}

bool HasOpenDirection(const ENUM_POSITION_TYPE type)
{
	int total = PositionsTotal();
	for(int i=0; i<total; ++i)
	{
		ulong ticket = PositionGetTicket(i);
		if(ticket == 0) continue;
		if(!PositionSelectByTicket(ticket)) continue;
		if(PositionGetInteger(POSITION_MAGIC) == (long)InpMagic && PositionGetString(POSITION_SYMBOL) == _Symbol)
		{
			if((ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE) == type)
				return true;
		}
	}
	return false;
}

bool GetATRPoints(double &atrPoints)
{
	double a0, a1;
	if(!CopyLatest(g_handleATR, 0, a0, a1)) return false;
	// ATR is in price; convert to points
	atrPoints = a0 / PointValue();
	return true;
}

//=========================
// Signal and confidence
//=========================
int ComputeConfidence(int &direction) // returns 0..100, sets direction: 1=long, -1=short, 0=none
{
	direction = 0;
	// Fetch indicator values
	double emaFast0, emaFast1; if(!CopyLatest(g_handleEmaFast, 0, emaFast0, emaFast1)) return 0;
	double emaSlow0, emaSlow1; if(!CopyLatest(g_handleEmaSlow, 0, emaSlow0, emaSlow1)) return 0;
	double rsi0, rsi1;         if(!CopyLatest(g_handleRSI,     0, rsi0, rsi1))         return 0;
	double stochK0, stochK1;   if(!CopyLatest(g_handleStoch,   0, stochK0, stochK1))   return 0; // buffer 0: K, buffer 1: D
	double stochD0, stochD1;   if(!CopyLatest(g_handleStoch,   1, stochD0, stochD1))   return 0;
	double macdMain0, macdMain1; if(!CopyLatest(g_handleMACD, 0, macdMain0, macdMain1)) return 0; // main line
	double macdSignal0, macdSignal1; if(!CopyLatest(g_handleMACD, 1, macdSignal0, macdSignal1)) return 0; // signal line

	// EMA cross score
	int scoreBull = 0;
	int scoreBear = 0;
	bool emaBullCross = (emaFast1 <= emaSlow1 && emaFast0 > emaSlow0);
	bool emaBearCross = (emaFast1 >= emaSlow1 && emaFast0 < emaSlow0);
	if(emaBullCross) scoreBull += 25;
	if(emaBearCross) scoreBear += 25;
	if(emaFast0 > emaSlow0) scoreBull += 10; else scoreBear += 10;

	// RSI bias
	if(rsi0 > 55) scoreBull += 15;
	if(rsi0 < 45) scoreBear += 15;
	if(rsi0 >= 30 && rsi0 <= 70) { scoreBull += 5; scoreBear += 5; } // not overextended

	// Stochastic cross in direction
	bool stochBull = (stochK1 <= stochD1 && stochK0 > stochD0) && stochK0 < 80;
	bool stochBear = (stochK1 >= stochD1 && stochK0 < stochD0) && stochK0 > 20;
	if(stochBull) scoreBull += 20;
	if(stochBear) scoreBear += 20;

	// MACD alignment
	bool macdBull = (macdMain0 > macdSignal0) && (macdMain0 > 0);
	bool macdBear = (macdMain0 < macdSignal0) && (macdMain0 < 0);
	if(macdBull) scoreBull += 20;
	if(macdBear) scoreBear += 20;

	// Momentum: slope of EMA fast
	double emaSlope = emaFast0 - emaFast1;
	if(emaSlope > 0) scoreBull += 5; else scoreBear += 5;

	// Normalize to 0..100 for each side (cap)
	if(scoreBull > 100) scoreBull = 100;
	if(scoreBear > 100) scoreBear = 100;

	// Decide direction by higher score
	int confidence = 0;
	if(scoreBull > scoreBear && InpAllowLongs)
	{
		direction = 1;
		confidence = scoreBull - (scoreBear/2); // penalize opposing signals
	}
	else if(scoreBear > scoreBull && InpAllowShorts)
	{
		direction = -1;
		confidence = scoreBear - (scoreBull/2);
	}
	else
	{
		direction = 0;
		confidence = 0;
	}
	if(confidence < 0) confidence = 0;
	if(confidence > 100) confidence = 100;
	return confidence;
}

//=========================
// Sizing and levels
//=========================
bool ComputeSLTPPoints(const int direction, const int confidence, double &slPoints, double &tpPoints)
{
	double atrPts;
	if(!GetATRPoints(atrPts)) return false;
	double conf = (double)confidence / 100.0;
	double slAtr = InpSL_ATR_Mult_High - (InpSL_ATR_Mult_High - InpSL_ATR_Mult_Low) * conf; // higher conf => smaller SL
	double tpAtr = InpTP_ATR_Mult_Low + (InpTP_ATR_Mult_High - InpTP_ATR_Mult_Low) * conf;  // higher conf => larger TP
	slPoints = MathMax(atrPts * slAtr, 10.0);
	tpPoints = MathMax(atrPts * tpAtr, 10.0);

	// honor broker stop level
	int stopLevelPoints = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
	if(stopLevelPoints > 0)
	{
		slPoints = MathMax(slPoints, (double)stopLevelPoints + 5);
		tpPoints = MathMax(tpPoints, (double)stopLevelPoints + 5);
	}
	return true;
}

double NormalizeLots(double lots)
{
	double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
	double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
	double step   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
	lots = MathMin(MathMax(lots, minLot), maxLot);
	return MathFloor(lots/step) * step;
}

double CalculatePositionSizeByRisk(const double slPoints)
{
	if(slPoints <= 0) return 0.0;
	double balance = AccountInfoDouble(ACCOUNT_BALANCE);
	double riskMoney = balance * InpRiskPerTradePercent / 100.0;
	// per point value for 1 lot
	double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
	double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
	if(tickValue <= 0 || tickSize <= 0) return 0.0;
	double pointValuePerLot = tickValue * (PointValue() / tickSize);
	if(pointValuePerLot <= 0) return 0.0;
	double lossPerLot = slPoints * pointValuePerLot;
	if(lossPerLot <= 0) return 0.0;
	double lots = riskMoney / lossPerLot;
	return NormalizeLots(lots);
}

bool PriceLevelsFromPoints(const int direction, const double slPoints, const double tpPoints, double &sl, double &tp)
{
	if(!SymbolInfoTick(_Symbol, g_lastTick)) return false;
	double price = (direction>0) ? g_lastTick.ask : g_lastTick.bid;
	if(direction>0)
	{
		sl = price - slPoints * PointValue();
		tp = price + tpPoints * PointValue();
	}
	else if(direction<0)
	{
		sl = price + slPoints * PointValue();
		tp = price - tpPoints * PointValue();
	}
	else return false;
	sl = NormalizeDouble(sl, DigitsCount());
	tp = NormalizeDouble(tp, DigitsCount());
	return true;
}

//=========================
// Trade placement
//=========================
bool OpenTrade(const int direction, const double lots, const double sl, const double tp)
{
	g_trade.SetExpertMagicNumber((long)InpMagic);
	g_trade.SetDeviationInPoints(InpDeviationPoints);
	bool ok = false;
	if(direction > 0) ok = g_trade.Buy(lots, _Symbol, 0.0, sl, tp, "SCALP_LONG");
	else if(direction < 0) ok = g_trade.Sell(lots, _Symbol, 0.0, sl, tp, "SCALP_SHORT");
	return ok;
}

void ManageOpenPositions()
{
	int total = PositionsTotal();
	for(int i=0; i<total; ++i)
	{
		ulong ticket = PositionGetTicket(i);
		if(ticket == 0) continue;
		if(!PositionSelectByTicket(ticket)) continue;
		if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
		if(PositionGetInteger(POSITION_MAGIC) != (long)InpMagic) continue;

		double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
		double sl = PositionGetDouble(POSITION_SL);
		double tp = PositionGetDouble(POSITION_TP);
		double profitPoints = 0.0;
		ENUM_POSITION_TYPE ptype = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
		if(!SymbolInfoTick(_Symbol, g_lastTick)) continue;
		if(ptype == POSITION_TYPE_BUY)
			profitPoints = (g_lastTick.bid - openPrice) / PointValue();
		else if(ptype == POSITION_TYPE_SELL)
			profitPoints = (openPrice - g_lastTick.ask) / PointValue();

		// Break-even
		if(InpUseBreakEven && profitPoints >= InpBreakEvenTriggerPoints)
		{
			double bePrice = (ptype == POSITION_TYPE_BUY) ? openPrice + InpBreakEvenOffsetPoints*PointValue() : openPrice - InpBreakEvenOffsetPoints*PointValue();
			bePrice = NormalizeDouble(bePrice, DigitsCount());
			if((ptype == POSITION_TYPE_BUY && (sl == 0.0 || sl < bePrice)) || (ptype == POSITION_TYPE_SELL && (sl == 0.0 || sl > bePrice)))
			{
				g_trade.PositionModify(ticket, bePrice, tp);
			}
		}

		// Trailing stop
		if(InpUseTrailing && profitPoints >= InpTrailingStartPoints)
		{
			double newSL = sl;
			if(ptype == POSITION_TYPE_BUY)
			{
				double trailPrice = g_lastTick.bid - InpTrailingStepPoints * PointValue();
				trailPrice = NormalizeDouble(trailPrice, DigitsCount());
				if(sl == 0.0 || trailPrice > sl) newSL = trailPrice;
			}
			else if(ptype == POSITION_TYPE_SELL)
			{
				double trailPrice = g_lastTick.ask + InpTrailingStepPoints * PointValue();
				trailPrice = NormalizeDouble(trailPrice, DigitsCount());
				if(sl == 0.0 || trailPrice < sl) newSL = trailPrice;
			}
			if(newSL != sl)
				g_trade.PositionModify(ticket, newSL, tp);
		}

		// Time exit by bars
		if(InpUseTimeExit)
		{
			datetime timeOpen = (datetime)PositionGetInteger(POSITION_TIME);
			// approximate bars since open by using bar times on signal timeframe
			datetime lastBarTime = iTime(_Symbol, InpTimeframe, 0);
			int barsSinceOpen = (int)((lastBarTime - timeOpen) / PeriodSeconds(InpTimeframe));
			if(barsSinceOpen >= InpMaxBarsInTrade)
			{
				g_trade.PositionClose(ticket);
			}
		}
	}
}

//=========================
// Lifecycle
//=========================
int OnInit()
{
	g_trade.SetExpertMagicNumber((long)InpMagic);
	// Set up indicators
	g_handleEmaFast = iMA(_Symbol, InpTimeframe, InpEMAFast, 0, MODE_EMA, PRICE_CLOSE);
	g_handleEmaSlow = iMA(_Symbol, InpTimeframe, InpEMASlow, 0, MODE_EMA, PRICE_CLOSE);
	g_handleRSI     = iRSI(_Symbol, InpTimeframe, InpRSIPeriod, PRICE_CLOSE);
	g_handleStoch   = iStochastic(_Symbol, InpTimeframe, InpStochK, InpStochD, InpStochSlow, MODE_STOCHLOWHIGH, STO_LOWHIGH);
	g_handleATR     = iATR(_Symbol, InpTimeframe, InpATRPeriod);
	g_handleMACD    = iMACD(_Symbol, InpTimeframe, InpMACDFast, InpMACDSlow, InpMACDSignal, PRICE_CLOSE);

	if(g_handleEmaFast==INVALID_HANDLE || g_handleEmaSlow==INVALID_HANDLE || g_handleRSI==INVALID_HANDLE ||
	   g_handleStoch==INVALID_HANDLE || g_handleATR==INVALID_HANDLE || g_handleMACD==INVALID_HANDLE)
	{
		Print("[Init] Failed to create indicator handles");
		return(INIT_FAILED);
	}
	return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason)
{
	if(g_handleEmaFast!=INVALID_HANDLE) IndicatorRelease(g_handleEmaFast);
	if(g_handleEmaSlow!=INVALID_HANDLE) IndicatorRelease(g_handleEmaSlow);
	if(g_handleRSI!=INVALID_HANDLE)     IndicatorRelease(g_handleRSI);
	if(g_handleStoch!=INVALID_HANDLE)   IndicatorRelease(g_handleStoch);
	if(g_handleATR!=INVALID_HANDLE)     IndicatorRelease(g_handleATR);
	if(g_handleMACD!=INVALID_HANDLE)    IndicatorRelease(g_handleMACD);
}

void OnTick()
{
	// Basic filters
	if(!CheckSpreadOK()) return;
	if(!CheckSessionOK()) return;

	// Avoid multiple open positions
	if(CountOpenPositions() >= InpMaxPositionsPerSymbol)
	{
		ManageOpenPositions();
		return;
	}

	// Avoid multiple entries per bar
	datetime barTime = iTime(_Symbol, InpTimeframe, 0);
	bool isNewBar = (barTime != g_lastSignalBarTime);
	if(!isNewBar)
	{
		ManageOpenPositions();
		return;
	}

	int direction = 0;
	int confidence = ComputeConfidence(direction);
	g_lastSignalBarTime = barTime;

	ManageOpenPositions();

	if(direction == 0) return;
	if(confidence < InpMinConfidenceToTrade) return;

	double slPts, tpPts; if(!ComputeSLTPPoints(direction, confidence, slPts, tpPts)) return;
	double lots = CalculatePositionSizeByRisk(slPts);
	if(lots <= 0.0) return;

	double sl, tp; if(!PriceLevelsFromPoints(direction, slPts, tpPts, sl, tp)) return;

	bool placed = OpenTrade(direction, lots, sl, tp);
	if(!placed)
		Print("[Order] Failed to place order. Error=", GetLastError());
}